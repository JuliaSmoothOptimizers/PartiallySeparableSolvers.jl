var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PartiallySeparableSolvers, Mod_partitioned_methods, Mod_TR_CG_part_data]","category":"page"},{"location":"reference/#PartiallySeparableSolvers.solver_TR_CG_Ab_NLP_LO-Union{Tuple{T}, Tuple{NLPModels.AbstractNLPModel, LinearOperators.AbstractLinearOperator{T}}} where T<:Number","page":"Reference","title":"PartiallySeparableSolvers.solver_TR_CG_Ab_NLP_LO","text":"(x, iter) = solver_TR_CG_Ab_NLP_LO(nlp::AbstractNLPModel, B::AbstractLinearOperator{T}; max_eval::Int = 10000, max_iter::Int = 10000, start_time::Float64 = time(), max_time::Float64 = 30.0,)\n\nA limited-memory quasi-Newton trust-region solver where the subproblems, whose quadratics terms are updated through the linear-operator B, are solved with a conjugate-gradient method (see Krylov.jl). The method return the point x and the number of iterations performed before it reaches the stopping criterias.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableSolvers.solver_TR_CG_Ab_NLP_LO_ges-Union{Tuple{T}, Tuple{NLPModels.AbstractNLPModel, LinearOperators.AbstractLinearOperator{T}}} where T<:Number","page":"Reference","title":"PartiallySeparableSolvers.solver_TR_CG_Ab_NLP_LO_ges","text":"ges = solver_TR_CG_Ab_NLP_LO_ges(nlp::AbstractNLPModel, B::AbstractLinearOperator{T}; max_eval::Int = 10000, max_iter::Int = 10000, start_time::Float64 = time(), max_time::Float64 = 30.0) where {T <: Number}\n\nReturn a GenericExecutionStats from the quasi-Newton trust-region method solver_TR_CG_Ab_NLP_LO given the linear-operator B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableSolvers.upgrade_TR_LO!-Union{Tuple{T}, Tuple{Float64, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, LinearOperators.AbstractLinearOperator{T}, NLPModels.AbstractNLPModel, Float64}} where T<:Number","page":"Reference","title":"PartiallySeparableSolvers.upgrade_TR_LO!","text":"Δ = upgrade_TR_LO(pk::Float64, x_k::AbstractVector{T}, s_k::AbstractVector{T}, g_k::AbstractVector{T},  y_k::AbstractVector{T},  B_k::AbstractLinearOperator{T}, nlp::AbstractNLPModel, Δ::Float64; η::Float64 = 1e-3, η1::Float64 = 0.75 ) where {T <: Number}\n\nUpdate the linear-operator Bₖ and return the trust-region radius Δ depending ρₖ the ratio computed beforehand from the step sₖ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableSolvers.Mod_partitioned_methods.PUS-Tuple{NLPModels.AbstractNLPModel}","page":"Reference","title":"PartiallySeparableSolvers.Mod_partitioned_methods.PUS","text":"ges = PUS(nlp::AbstractNLPModel; name = :plse, kwargs...)\n\nPUS (partitioned update solver) return a ges::GenericExecutionStats from a partitioned quasi-Newton trust-region method. It can perform several variants, which can be select with the optional argument name. You will perform a:\n\nPBFGS method with name=:pbfgs;\nPSR1 method with name=:psr1;\nPSE method with name=:pse;\nPLBFGS method with name=:plbfgs;\nPLSR1 method with name=:plsr1;\nPLSE method with name=:plse, by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableSolvers.Mod_partitioned_methods.get_expr_tree-Union{Tuple{NLPModelsJuMP.MathOptNLPModel}, Tuple{T}} where T<:Number","page":"Reference","title":"PartiallySeparableSolvers.Mod_partitioned_methods.get_expr_tree","text":"expr_tree, n, x0 = get_expr_tree(nlp::MathOptNLPModel; x0::Vector{T} = copy(nlp.meta.x0), kwargs...) where {T <: Number}\nexpr_tree, n, x0 = get_expr_tree(adnlp::ADNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T <: Number}\n\nReturn the expr_tree, the size n and the initial point x0 from either a MathOptNLPModel or a ADNLPModel.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableSolvers.Mod_TR_CG_part_data.Counter","page":"Reference","title":"PartiallySeparableSolvers.Mod_TR_CG_part_data.Counter","text":"Counter\n\nSubstitute to NLPModels.Counters since the partitioned methods don't relie (for now) on PartiallySeparableNLPModels. It has fields:\n\nneval_obj::Int: count objective evaluations;\nneval_grad::Int: count gradient computations;\nneval_Hprod::Int: count Hessian-approximation-vector products.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableSolvers.Mod_TR_CG_part_data.TR_CG_PD-Tuple{PartiallySeparableNLPModels.Mod_ab_partitioned_data.PartitionedData}","page":"Reference","title":"PartiallySeparableSolvers.Mod_TR_CG_part_data.TR_CG_PD","text":"(x, iter) = TR_CG_PD(part_data::PartiallySeparableNLPModels.PartitionedData; x::AbstractVector = copy(get_x(part_data)), n::Int = get_n(part_data), max_eval::Int = 10000, max_iter::Int = 10000, max_time::Float64 = 30.0, atol::Real = √eps(eltype(x)), rtol::Real = √eps(eltype(x)), start_time::Float64 = time(), η::Float64 = 1e-3, η₁::Float64 = 0.75, # > η Δ::Float64 = 1.0, ϵ::Float64 = 1e-6, ϕ::Float64 = 2.0, ∇f₀::AbstractVector = PartiallySeparableNLPModels.evaluate_grad_part_data(part_data, x), cpt::Counter = Counter(0, 0, 0), iter_print::Int64 = Int(floor(max_iter / 100)), T = eltype(x), verbose = true, kwargs...)\n\nPartitioned quasi-Newton trust-region method apply on the partitioned structures of part_data. The method return the point x and the number of iterations performed before it reaches the stopping criterias.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableSolvers.Mod_TR_CG_part_data.compute_ratio-Union{Tuple{T}, Tuple{AbstractVector{T}, T, Vector{T}, PartiallySeparableNLPModels.Mod_ab_partitioned_data.PartitionedData, LinearOperators.AbstractLinearOperator{T}, AbstractVector{T}}} where T<:Number","page":"Reference","title":"PartiallySeparableSolvers.Mod_TR_CG_part_data.compute_ratio","text":"ρₖ = compute_ratio(x::AbstractVector{T}, fₖ::T, sₖ::Vector{T}, part_data::PartiallySeparableNLPModels.PartitionedData, B::AbstractLinearOperator{T}, gₖ::AbstractVector{T}; cpt::Counter = Counter(0, 0, 0))\n\nCompute the ratio between the actual loss and the expected loss using part_data, the current point x and the step s. g_k must be the gradient at x and B the linear-operator paired to part_data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableSolvers.Mod_TR_CG_part_data.generic_algorithm_wrapper-Tuple{NLPModels.AbstractNLPModel, PartiallySeparableNLPModels.Mod_ab_partitioned_data.PartitionedData}","page":"Reference","title":"PartiallySeparableSolvers.Mod_TR_CG_part_data.generic_algorithm_wrapper","text":"ges = generic_algorithm_wrapper(nlp::AbstractNLPModel, part_data::PartiallySeparableNLPModels.PartitionedData; max_eval::Int = 10000, max_iter::Int = 10000, start_time::Float64 = time(), max_time::Float64 = 30.0, ϵ::Float64 = 1e-6, name = part_data.name, name_method::String = \"Trust-region \" * String(name), kwargs...)\n\nProduce a GenericExecutionStats for a partitioned quasi-Newton trust-region method. It requires the partitioned structures of part_data::PartitionedDate paired with an nlp model. The counter nlp.counters are updated with the informations of Mod_TR_CG_part_data.Counter to ease the definition of a GenericExecutionStats.\n\n\n\n\n\n","category":"method"},{"location":"#PartiallySeparableSolvers.jl","page":"Home","title":"PartiallySeparableSolvers.jl","text":"","category":"section"},{"location":"tutorial/#PartiallySeparableSolvers.jl-Tutorial","page":"Tutorial","title":"PartiallySeparableSolvers.jl Tutorial","text":"","category":"section"}]
}
